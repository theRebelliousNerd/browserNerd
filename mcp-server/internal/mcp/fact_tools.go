package mcp

import (
	"context"
	"fmt"
	"strings"
	"time"

	"browsernerd-mcp-server/internal/mangle"
)

// PushFactsTool ingests arbitrary facts into the Mangle engine (useful for demos/tests).
type PushFactsTool struct {
	engine *mangle.Engine
}

func (t *PushFactsTool) Name() string { return "push-facts" }
func (t *PushFactsTool) Description() string {
	return `Manually inject facts into the Mangle reasoning engine.

WHEN TO USE:
- Testing Mangle rules without browser events
- Injecting external data for reasoning
- Setting up initial state for rule evaluation
- Debugging rule logic with known facts

EXAMPLE:
push-facts({facts: [
  {predicate: "user_logged_in", args: ["session-1", "admin"]},
  {predicate: "page_loaded", args: ["session-1", "/dashboard"]}
]})

Then query with: query-facts("user_logged_in(Session, Role).")

NOTE: Most facts are auto-generated by browser events. Use this for
manual injection or testing scenarios.`
}
func (t *PushFactsTool) InputSchema() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"facts": map[string]interface{}{
				"type":        "array",
				"description": "Array of facts {predicate, args}",
				"items": map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"predicate": map[string]interface{}{"type": "string"},
						"args": map[string]interface{}{
							"type":  "array",
							"items": map[string]interface{}{"type": "string"},
						},
					},
					"required": []string{"predicate"},
				},
			},
		},
		"required": []string{"facts"},
	}
}
func (t *PushFactsTool) Execute(ctx context.Context, args map[string]interface{}) (interface{}, error) {
	rawFacts, ok := args["facts"].([]interface{})
	if !ok {
		return nil, fmt.Errorf("facts must be an array")
	}

	parsed := make([]mangle.Fact, 0, len(rawFacts))
	now := time.Now()
	for _, raw := range rawFacts {
		record, ok := raw.(map[string]interface{})
		if !ok {
			continue
		}
		pred := getStringFromMap(record, "predicate")
		if pred == "" {
			continue
		}
		argsValue, _ := record["args"].([]interface{})
		parsed = append(parsed, mangle.Fact{
			Predicate: pred,
			Args:      argsValue,
			Timestamp: now,
		})
	}

	if len(parsed) == 0 {
		return nil, fmt.Errorf("no valid facts provided")
	}

	if err := t.engine.AddFacts(ctx, parsed); err != nil {
		return nil, err
	}

	return map[string]interface{}{
		"accepted": len(parsed),
		"ready":    t.engine.Ready(),
	}, nil
}

type ReadFactsTool struct {
	engine *mangle.Engine
}

func (t *ReadFactsTool) Name() string { return "read-facts" }
func (t *ReadFactsTool) Description() string {
	return `Inspect the current fact buffer to see what the Mangle engine knows.

WHEN TO USE:
- Debugging: See what facts have been captured
- Before writing rules: Understand available predicates
- After browser events: Verify facts were emitted
- Troubleshooting: Why isn't my rule matching?

WORKFLOW TIP:
1. Perform browser actions (navigate, click, etc.)
2. read-facts to see what was captured
3. Write rules based on actual fact structure

Returns most recent facts (default 25, adjustable with limit param).
Facts include: predicate name, arguments, and timestamp.`
}
func (t *ReadFactsTool) InputSchema() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"limit": map[string]interface{}{
				"type":        "integer",
				"description": "Maximum number of facts to return (default 25)",
			},
		},
	}
}
func (t *ReadFactsTool) Execute(_ context.Context, args map[string]interface{}) (interface{}, error) {
	limit := getIntArg(args, "limit", 25)
	if limit <= 0 {
		limit = 25
	}

	facts := t.engine.Facts()
	if len(facts) > limit {
		facts = facts[len(facts)-limit:]
	}
	return map[string]interface{}{
		"count": len(facts),
		"facts": facts,
	}, nil
}

// QueryFactsTool executes a Mangle query string and returns variable bindings.
type QueryFactsTool struct {
	engine *mangle.Engine
}

func (t *QueryFactsTool) Name() string { return "query-facts" }
func (t *QueryFactsTool) Description() string {
	return `Execute a Mangle query to find facts matching a pattern.

WHEN TO USE:
- Finding specific facts by pattern
- Extracting values from the fact store
- Checking if conditions are met
- Ad-hoc fact exploration

QUERY SYNTAX (Mangle/Datalog):
- Variables start with uppercase: Session, Url, Status
- Wildcards use underscore: _
- Queries end with period: .

EXAMPLES:
- "navigation_event(Session, Url, _)."     -> All navigation events
- "console_event(\"error\", Msg, _)."      -> All error messages
- "failed_request(_, Url, Status)."        -> All failed requests

Returns: Array of variable bindings for each match.`
}
func (t *QueryFactsTool) InputSchema() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"query": map[string]interface{}{
				"type":        "string",
				"description": "Mangle query string (e.g., caused_by(Error, ReqId).)",
			},
		},
		"required": []string{"query"},
	}
}
func (t *QueryFactsTool) Execute(ctx context.Context, args map[string]interface{}) (interface{}, error) {
	query := getStringArg(args, "query")
	if query == "" {
		return nil, fmt.Errorf("query is required")
	}
	query = strings.TrimSpace(query)
	if !strings.HasSuffix(query, ".") {
		query += "."
	}

	results, err := t.engine.Query(ctx, query)
	if err != nil {
		return nil, err
	}
	return map[string]interface{}{
		"count":   len(results),
		"results": normalizeQueryBindings(results),
	}, nil
}

func normalizeQueryBindings(results []mangle.QueryResult) []map[string]interface{} {
	normalized := make([]map[string]interface{}, 0, len(results))
	for _, row := range results {
		out := make(map[string]interface{}, len(row))
		for k, v := range row {
			if strings.HasPrefix(k, "__anon_") {
				out["_"+strings.TrimPrefix(k, "__anon_")] = v
			} else {
				out[k] = v
			}
		}
		normalized = append(normalized, out)
	}
	return normalized
}

// SubmitRuleTool adds a new rule to the running Mangle program.
type SubmitRuleTool struct {
	engine *mangle.Engine
}

func (t *SubmitRuleTool) Name() string { return "submit-rule" }
func (t *SubmitRuleTool) Description() string {
	return `Add a Mangle rule for deriving new facts from existing ones.

WHEN TO USE:
- Defining custom conditions for wait-for-condition
- Creating derived facts for complex assertions
- Building causal reasoning chains
- Setting up execute-plan action sequences

RULE SYNTAX:
derived_fact(Args) :- source_fact1(Args), source_fact2(Args).

EXAMPLES:
- "login_success() :- navigation_event(_, \"/dashboard\", _)."
- "api_error(Url) :- failed_request(_, Url, Status), Status >= 500."
- "action(\"click\", \"submit-btn\") :- form_ready()."

WORKFLOW:
1. submit-rule to define the condition
2. Use evaluate-rule or wait-for-condition with the predicate name

Rules persist for the session and auto-evaluate as facts arrive.`
}
func (t *SubmitRuleTool) InputSchema() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"rule": map[string]interface{}{
				"type":        "string",
				"description": "Mangle rule source (e.g., test_passed() :- navigation_event(_, \"/dashboard\", _).)",
			},
		},
		"required": []string{"rule"},
	}
}
func (t *SubmitRuleTool) Execute(_ context.Context, args map[string]interface{}) (interface{}, error) {
	rule := getStringArg(args, "rule")
	if rule == "" {
		return nil, fmt.Errorf("rule is required")
	}
	if err := t.engine.AddRule(rule); err != nil {
		return nil, err
	}
	return map[string]interface{}{
		"status": "ok",
	}, nil
}

// EvaluateRuleTool runs full program evaluation and returns derived facts for a predicate.
type EvaluateRuleTool struct {
	engine *mangle.Engine
}

func (t *EvaluateRuleTool) Name() string { return "evaluate-rule" }
func (t *EvaluateRuleTool) Description() string {
	return `Check if a derived predicate has any matching facts RIGHT NOW.

USE INSTEAD OF query-facts when:
- Checking if a rule's head predicate derived any facts
- Testing rule logic immediately (no waiting)
- Debugging why a rule isn't deriving expected facts

WORKFLOW:
1. submit-rule("test_passed() :- navigation_event(_, \"/success\", _).")
2. navigate to /success page
3. evaluate-rule("test_passed") -> returns derived facts if rule matched

Returns: {predicate, facts: [...], count} - empty facts array if no match.

For WAITING until a condition is true, use wait-for-condition instead.`
}
func (t *EvaluateRuleTool) InputSchema() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"predicate": map[string]interface{}{
				"type":        "string",
				"description": "Predicate name to fetch (e.g., test_passed)",
			},
		},
		"required": []string{"predicate"},
	}
}
func (t *EvaluateRuleTool) Execute(ctx context.Context, args map[string]interface{}) (interface{}, error) {
	predicate := getStringArg(args, "predicate")
	if predicate == "" {
		return nil, fmt.Errorf("predicate is required")
	}

	facts, err := t.engine.Evaluate(ctx, predicate)
	if err != nil {
		return nil, err
	}
	return map[string]interface{}{
		"predicate": predicate,
		"facts":     facts,
		"count":     len(facts),
	}, nil
}

// SubscribeRuleTool subscribes to watch for derived facts from a predicate (Watch Mode - PRD 5.2).
type SubscribeRuleTool struct {
	engine *mangle.Engine
}

func (t *SubscribeRuleTool) Name() string { return "subscribe-rule" }
func (t *SubscribeRuleTool) Description() string {
	return `Block until a predicate derives facts, then return immediately.

USE INSTEAD OF wait-for-condition when:
- You need push-based notification (vs polling)
- Watching for rule derivations in real-time
- Building reactive automation flows

WORKFLOW:
1. submit-rule("error_detected() :- console_event(\"error\", _, _).")
2. subscribe-rule("error_detected", timeout_ms: 30000)
3. Tool blocks until an error occurs or timeout

Returns on trigger: {status: "triggered", predicate, facts, count}
Returns on timeout: {status: "timeout", predicate}

PREFER wait-for-condition for most use cases - it's more flexible.
Use subscribe-rule for long-running watches or reactive patterns.`
}
func (t *SubscribeRuleTool) InputSchema() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"predicate": map[string]interface{}{
				"type":        "string",
				"description": "Predicate name to watch (e.g., test_passed, slow_api)",
			},
			"timeout_ms": map[string]interface{}{
				"type":        "integer",
				"description": "Timeout in milliseconds (default 30000)",
			},
		},
		"required": []string{"predicate"},
	}
}
func (t *SubscribeRuleTool) Execute(ctx context.Context, args map[string]interface{}) (interface{}, error) {
	predicate := getStringArg(args, "predicate")
	if predicate == "" {
		return nil, fmt.Errorf("predicate is required")
	}

	timeout := time.Duration(getIntArg(args, "timeout_ms", 30000)) * time.Millisecond
	if timeout <= 0 {
		timeout = 30 * time.Second
	}

	// Create subscription channel
	ch := make(chan mangle.WatchEvent, 10)
	_ = t.engine.Subscribe(predicate, ch)
	defer t.engine.Unsubscribe(predicate, ch)

	// Wait for event or timeout
	select {
	case event := <-ch:
		return map[string]interface{}{
			"status":    "triggered",
			"predicate": event.Predicate,
			"facts":     event.Facts,
			"count":     len(event.Facts),
			"timestamp": event.Timestamp.UnixMilli(),
		}, nil
	case <-time.After(timeout):
		return map[string]interface{}{
			"status":    "timeout",
			"predicate": predicate,
		}, nil
	case <-ctx.Done():
		return nil, ctx.Err()
	}
}

// QueryTemporalTool queries facts within a time window.
type QueryTemporalTool struct {
	engine *mangle.Engine
}

func (t *QueryTemporalTool) Name() string { return "query-temporal" }
func (t *QueryTemporalTool) Description() string {
	return `Query facts filtered by timestamp - find what happened in a time window.

WHEN TO USE:
- "What happened in the last 5 seconds?"
- "What network requests occurred before this error?"
- Correlating events by time
- Debugging timing-sensitive issues

EXAMPLES:
- query-temporal("net_request", after_ms: Date.now() - 5000)
  -> Requests in last 5 seconds

- query-temporal("console_event", before_ms: errorTimestamp)
  -> Console events before an error occurred

USE INSTEAD OF query-facts when time filtering matters.
Both after_ms and before_ms are epoch milliseconds.`
}
func (t *QueryTemporalTool) InputSchema() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"predicate": map[string]interface{}{
				"type":        "string",
				"description": "Predicate to filter",
			},
			"after_ms": map[string]interface{}{
				"type":        "integer",
				"description": "Optional lower bound (epoch millis). Default: 0",
			},
			"before_ms": map[string]interface{}{
				"type":        "integer",
				"description": "Optional upper bound (epoch millis). Default: now",
			},
		},
		"required": []string{"predicate"},
	}
}
func (t *QueryTemporalTool) Execute(_ context.Context, args map[string]interface{}) (interface{}, error) {
	predicate := getStringArg(args, "predicate")
	if predicate == "" {
		return nil, fmt.Errorf("predicate is required")
	}

	afterMS := getIntArg(args, "after_ms", 0)
	beforeMS := getIntArg(args, "before_ms", int(time.Now().UnixMilli()))

	after := time.UnixMilli(int64(afterMS))
	before := time.UnixMilli(int64(beforeMS))

	facts := t.engine.QueryTemporal(predicate, after, before)
	return map[string]interface{}{
		"predicate": predicate,
		"count":     len(facts),
		"facts":     facts,
	}, nil
}

// AwaitFactTool lets agents register simple assertions without full rule evaluation.
type AwaitFactTool struct {
	engine *mangle.Engine
}

func (t *AwaitFactTool) Name() string { return "await-fact" }
func (t *AwaitFactTool) Description() string {
	return `Wait for a specific fact to appear (simple assertions without rules).

USE INSTEAD OF wait-for-condition when:
- Waiting for a base fact, not a derived rule
- Simple predicate matching is sufficient
- You don't need complex conditions

EXAMPLES:
- await-fact("navigation_event") -> Wait for ANY navigation
- await-fact("navigation_event", args: ["session-1", "/dashboard"])
  -> Wait for specific navigation

COMPARISON:
- await-fact: Simple, direct fact matching
- await-conditions: Multiple facts (AND logic)
- wait-for-condition: Derived rules, wildcards, complex logic

Returns: {predicate, status: "passed"|"timeout"}`
}
func (t *AwaitFactTool) InputSchema() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"predicate": map[string]interface{}{
				"type":        "string",
				"description": "Predicate name to watch for",
			},
			"args": map[string]interface{}{
				"type":        "array",
				"description": "Optional positional args to match exactly",
				"items":       map[string]interface{}{"type": "string"},
			},
			"timeout_ms": map[string]interface{}{
				"type":        "integer",
				"description": "Optional timeout in milliseconds (default 5000)",
			},
		},
		"required": []string{"predicate"},
	}
}
func (t *AwaitFactTool) Execute(ctx context.Context, args map[string]interface{}) (interface{}, error) {
	predicate := getStringArg(args, "predicate")
	if predicate == "" {
		return nil, fmt.Errorf("predicate is required")
	}
	wantArgs, _ := args["args"].([]interface{})
	timeout := time.Duration(getIntArg(args, "timeout_ms", 5000)) * time.Millisecond
	if timeout <= 0 {
		timeout = 5 * time.Second
	}

	deadline := time.Now().Add(timeout)
	for {
		if matchFact(t.engine.FactsByPredicate(predicate), wantArgs) {
			return map[string]interface{}{
				"predicate": predicate,
				"status":    "passed",
			}, nil
		}

		if time.Now().After(deadline) {
			return map[string]interface{}{
				"predicate": predicate,
				"status":    "timeout",
			}, nil
		}

		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		case <-time.After(200 * time.Millisecond):
		}
	}
}

// AwaitConditionsTool waits until all provided predicate/arg tuples appear.
type AwaitConditionsTool struct {
	engine *mangle.Engine
}

func (t *AwaitConditionsTool) Name() string { return "await-conditions" }
func (t *AwaitConditionsTool) Description() string {
	return `Wait until ALL specified conditions are true (logical AND).

WHEN TO USE:
- Multiple facts must ALL exist before proceeding
- Verifying complex page state
- Waiting for multiple async operations to complete

EXAMPLE:
await-conditions({
  conditions: [
    {predicate: "navigation_event", args: ["session-1", "/dashboard"]},
    {predicate: "dom_text", args: ["_", "Welcome"]}
  ],
  timeout_ms: 10000
})
-> Waits for BOTH navigation AND welcome text

COMPARISON:
- await-fact: Single fact
- await-conditions: Multiple facts, ALL must match (AND)
- wait-for-condition: Derived rules with complex logic

Returns: {status: "passed"|"timeout", conditions: count}`
}
func (t *AwaitConditionsTool) InputSchema() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"conditions": map[string]interface{}{
				"type":        "array",
				"description": "List of {predicate, args?} conditions to satisfy",
				"items": map[string]interface{}{
					"type": "object",
					"properties": map[string]interface{}{
						"predicate": map[string]interface{}{"type": "string"},
						"args": map[string]interface{}{
							"type":  "array",
							"items": map[string]interface{}{"type": "string"},
						},
					},
					"required": []string{"predicate"},
				},
			},
			"timeout_ms": map[string]interface{}{
				"type":        "integer",
				"description": "Timeout in milliseconds (default 8000)",
			},
		},
		"required": []string{"conditions"},
	}
}
func (t *AwaitConditionsTool) Execute(ctx context.Context, args map[string]interface{}) (interface{}, error) {
	rawConds, ok := args["conditions"].([]interface{})
	if !ok || len(rawConds) == 0 {
		return nil, fmt.Errorf("conditions must be a non-empty array")
	}

	conds := make([]mangle.Fact, 0, len(rawConds))
	for _, raw := range rawConds {
		m, ok := raw.(map[string]interface{})
		if !ok {
			continue
		}
		pred := getStringFromMap(m, "predicate")
		if pred == "" {
			continue
		}
		argList, _ := m["args"].([]interface{})
		conds = append(conds, mangle.Fact{Predicate: pred, Args: argList})
	}

	if len(conds) == 0 {
		return nil, fmt.Errorf("no valid conditions provided")
	}

	timeout := time.Duration(getIntArg(args, "timeout_ms", 8000)) * time.Millisecond
	if timeout <= 0 {
		timeout = 8 * time.Second
	}
	deadline := time.Now().Add(timeout)

	for {
		if t.engine.MatchesAll(conds) {
			return map[string]interface{}{
				"status":     "passed",
				"conditions": len(conds),
			}, nil
		}
		if time.Now().After(deadline) {
			return map[string]interface{}{
				"status":     "timeout",
				"conditions": len(conds),
			}, nil
		}

		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		case <-time.After(200 * time.Millisecond):
		}
	}
}
